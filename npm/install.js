#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const os = require('os');
const { execSync } = require('child_process');

function detectShell() {
  const shell = process.env.SHELL || '';
  
  if (shell.includes('zsh')) return 'zsh';
  if (shell.includes('bash')) return 'bash';
  if (shell.includes('fish')) return 'fish';
  
  // Default fallback
  return 'bash';
}

function getCompletionPaths(shell) {
  const homeDir = os.homedir();
  
  switch (shell) {
    case 'zsh':
      return [
        path.join(homeDir, '.zsh', 'completions'),
        path.join(homeDir, '.zsh_completion.d'),
        '/usr/local/share/zsh/site-functions'
      ];
    case 'bash':
      return [
        path.join(homeDir, '.bash_completion.d'),
        '/etc/bash_completion.d'
      ];
    case 'fish':
      return [
        path.join(homeDir, '.config', 'fish', 'completions')
      ];
    default:
      return [];
  }
}

function findWritableCompletionDir(shell) {
  const paths = getCompletionPaths(shell);
  
  for (const dir of paths) {
    try {
      // Try to create the directory if it doesn't exist
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
      
      // Test if we can write to it
      fs.accessSync(dir, fs.constants.W_OK);
      return dir;
    } catch (error) {
      continue;
    }
  }
  
  return null;
}

function getVersionInfo() {
  try {
    const packagePath = path.join(__dirname, '..', 'package.json');
    const packageJson = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
    return {
      version: packageJson.version,
      name: packageJson.name
    };
  } catch (error) {
    return { version: 'unknown', name: 'claudectl' };
  }
}

function getInstalledVersion(completionFile) {
  try {
    if (!fs.existsSync(completionFile)) return null;
    const content = fs.readFileSync(completionFile, 'utf8');
    const versionMatch = content.match(/# Version: ([\d\.]+)/);
    return versionMatch ? versionMatch[1] : null;
  } catch (error) {
    return null;
  }
}

function verifyCompletion(shell) {
  try {
    // Try to source the completion and test basic functionality
    const testCmd = process.platform === 'win32' 
      ? 'where claudectl > nul 2>&1' 
      : 'which claudectl > /dev/null 2>&1';
    
    execSync(testCmd, { timeout: 5000 });
    return true;
  } catch (error) {
    return false;
  }
}

function printProgress(message, success = true) {
  const icon = success ? '✓' : '✗';
  console.log(`${icon} ${message}`);
}

function installCompletions() {
  try {
    console.log('🚀 Installing shell completions for claudectl...');
    
    const versionInfo = getVersionInfo();
    printProgress(`Detected version: ${versionInfo.version}`);
    
    const shell = detectShell();
    printProgress(`Detected shell: ${shell}`);
    
    const completionDir = findWritableCompletionDir(shell);
    if (!completionDir) {
      printProgress('No writable completion directory found, skipping installation', false);
      console.log('💡 Try running: npm run setup -- repair');
      return;
    }
    
    printProgress(`Using completion directory: ${completionDir}`);
    
    const sourceDir = path.join(__dirname, '..', 'completions');
    let sourceFile, targetFile;
    
    switch (shell) {
      case 'zsh':
        sourceFile = path.join(sourceDir, '_claudectl');
        targetFile = path.join(completionDir, '_claudectl');
        break;
      case 'bash':
        sourceFile = path.join(sourceDir, 'claudectl.bash');
        targetFile = path.join(completionDir, 'claudectl');
        break;
      case 'fish':
        sourceFile = path.join(sourceDir, 'claudectl.fish');
        targetFile = path.join(completionDir, 'claudectl.fish');
        break;
      default:
        console.log(`Unsupported shell: ${shell}`);
        return;
    }
    
    if (!fs.existsSync(sourceFile)) {
      console.log(`Completion file not found: ${sourceFile}`);
      return;
    }
    
    // Check if update is needed
    const installedVersion = getInstalledVersion(targetFile);
    const needsUpdate = !installedVersion || installedVersion !== versionInfo.version;
    
    if (!needsUpdate && fs.existsSync(targetFile)) {
      printProgress(`Completions already up to date (v${installedVersion})`);
      return;
    }
    
    // Copy completion file
    fs.copyFileSync(sourceFile, targetFile);
    printProgress('Copied completion file');
    
    // Add version header to completion file
    const content = fs.readFileSync(targetFile, 'utf8');
    const versionedContent = `# Version: ${versionInfo.version}\n# Generated by ${versionInfo.name} npm install\n\n${content}`;
    fs.writeFileSync(targetFile, versionedContent);
    
    // Patch the completion file to add dynamic task completion
    patchCompletionFile(targetFile, shell);
    printProgress('Applied dynamic task completion');
    
    printProgress(`Installed completion to: ${targetFile}`);
    
    // Add source line to shell config if needed
    addToShellConfig(shell, completionDir);
    
    // Verify installation
    const verified = verifyCompletion(shell);
    if (verified) {
      printProgress('✨ Shell completions installed successfully!');
      console.log('💡 Restart your terminal or run `exec $SHELL` to activate completions.');
    } else {
      printProgress('Installation completed but verification failed', false);
      console.log('💡 If completions don\'t work, try: npm run setup -- repair');
    }
    
  } catch (error) {
    printProgress(`Failed to install completions: ${error.message}`, false);
    console.log('💡 Troubleshooting:');
    console.log('   - Try running: npm run setup -- repair');
    console.log('   - Check file permissions in your home directory');
    console.log('   - Verify your shell configuration');
    // Don't fail the installation if completions fail
  }
}

function patchCompletionFile(filePath, shell) {
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    
    if (shell === 'zsh') {
      // Replace the static task_name completion with dynamic completion
      // Target specifically the rm command's task_name completion
      content = content.replace(
        /(rm\)\s*\n[^;]+':task_name:')([^']+)/,
        '$1_claudectl_tasks$2'
      );
      
      // Add the dynamic completion function with error handling
      const dynamicFunction = `
# Dynamic task completion function with error handling
_claudectl_tasks() {
  local tasks
  local cmd_output
  
  # Try to get tasks, with timeout and error handling
  if cmd_output=$(timeout 3 claudectl list 2>/dev/null); then
    # Extract task names from claudectl list output (first column, skip empty lines and headers)
    tasks=($(echo "$cmd_output" | awk 'NF > 0 && $1 !~ /^[●◯]/ && NR > 1 {print $1}' | head -20))
    if [ ${#tasks[@]} -gt 0 ]; then
      _describe 'available tasks' tasks
      return 0
    fi
  fi
  
  # Fallback to default completion if claudectl fails
  _default
}`;
      
      // Insert the function before the final compdef
      content = content.replace(/^if \[ "\$funcstack\[1\]" = "_claudectl" \]; then/m, dynamicFunction + '\n\nif [ "$funcstack[1]" = "_claudectl" ]; then');
    } else if (shell === 'bash') {
      // For bash, add basic dynamic completion
      const bashFunction = `
# Basic dynamic task completion for bash
_claudectl_tasks() {
  local cur="\${COMP_WORDS[COMP_CWORD]}"
  local tasks
  
  if tasks=$(timeout 3 claudectl list 2>/dev/null | awk 'NF > 0 && NR > 1 {print $1}' | head -20); then
    COMPREPLY=($(compgen -W "$tasks" -- "$cur"))
  fi
}`;
      
      content = content + bashFunction;
    }
    
    fs.writeFileSync(filePath, content);
  } catch (error) {
    console.log(`Could not patch completion file: ${error.message}`);
  }
}

function addToShellConfig(shell, completionDir) {
  const homeDir = os.homedir();
  let configFile, sourceLine;
  
  switch (shell) {
    case 'zsh':
      configFile = path.join(homeDir, '.zshrc');
      sourceLine = `# Added by claudectl\nfpath+="${completionDir}"\nautoload -U compinit && compinit`;
      break;
    case 'bash':
      configFile = path.join(homeDir, '.bashrc');
      sourceLine = `# Added by claudectl\n[ -f "${path.join(completionDir, 'claudectl')}" ] && source "${path.join(completionDir, 'claudectl')}"`;
      break;
    case 'fish':
      // Fish automatically loads completions from ~/.config/fish/completions/
      return;
    default:
      return;
  }
  
  try {
    // Check if already added
    if (fs.existsSync(configFile)) {
      const content = fs.readFileSync(configFile, 'utf8');
      if (content.includes('# Added by claudectl')) {
        return; // Already added
      }
    }
    
    // Append to config file
    fs.appendFileSync(configFile, `\n${sourceLine}\n`);
    console.log(`Added completion setup to ${configFile}`);
    
  } catch (error) {
    console.log(`Could not update ${configFile}: ${error.message}`);
  }
}

// Only run if this script is executed directly
if (require.main === module) {
  installCompletions();
}

module.exports = { installCompletions };